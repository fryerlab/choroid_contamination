---
title: "GTEx Hippocampus DEG"
author: "Kennedi Todd"
date: "3/12/2021"
output: pdf_document
---

Load packages
```{r}
library(BiocParallel)
library(dplyr)
library(edgeR)
library(ggplot2)
library(ggrepel)
library(gplots)
library(grid)
library(gridExtra)
library(knitr)
library(stringr)
library(variancePartition)
```

Set working directory.
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/Users/m214960/Documents/GTEx/")
```

Read in files.
```{r}
file1 <- read.delim(file = "Brain_Hippocampus", header = TRUE, sep = "\t")
file2 <- read.delim(file = "GTEx_Analysis_v8_Annotations_SubjectPhenotypesDS.txt", header = TRUE, sep = "\t")
gtf.file <- "gencode.v26.GRCh38.genes.gtf"
gtf.gr <- rtracklayer::import(gtf.file)
gtf.df <- as.data.frame(gtf.gr)
gtf.df.condensed <- unique(gtf.df[,c("type","gene_type","gene_name","gene_id","seqnames")])
```

Reformat and rename files.
```{r}
gtf.genes <- gtf.df.condensed[gtf.df.condensed$type == "gene",]
colnames(file2) <- c("subject_id","sex","age","hardy_scale")
metadata <- file2
file1$X <- NULL
counts <- file1
colnames(counts)[1:2] <- c("gene_id","gene_name")
```

Merge to view info in one file.
```{r}
merged_counts <- left_join(counts, gtf.genes, by = "gene_id")
merged_counts <- merged_counts[,c(1,2,202:205,3:201)]
```

Look to see if any NA values or replicated gene names.
```{r}
table(is.na(merged_counts$gene_name.x))
table(duplicated(merged_counts$gene_name.x))
```
There are no NA values.  However, 1,608 gene names are repetitive.

Let's view the repetitive gene names.
```{r}
table(merged_counts$gene_name.x[duplicated(merged_counts$gene_name.x)])
```

Let's view the gene_type for the repetitive genes.
```{r}
table(merged_counts$gene_type[duplicated(merged_counts$gene_name.x)])
```

Let's subset the data to counts on the Y chromosome.
```{r}
chrY_counts <- merged_counts[merged_counts$seqnames == "chrY",]
```


-------------------------------CREATE DGE OBJECT--------------------------------

```{r}
counts$mean <- NULL
counts$median <- NULL
counts$gene_id <- NULL
```

```{r}
keep <- !duplicated(counts$gene_name) # true when no duplicate
counts.unique <- counts[keep,]
dim(counts)
dim(counts.unique)
```
Went from 56,200 genes to 54,592.  
RNAs were mainly lost.

```{r}
rownames(counts.unique) <- counts.unique$gene_name
counts.unique$gene_name <- NULL
```


Change sex column from numbers to letters.
```{r}
# male = 1, female = 2
sex_nums <- metadata$sex
sex_letters <- vector()
for (i in 1:length(sex_nums)) {
  if (sex_nums[i] == 1) {
    sex_letters <- c(sex_letters, "M")
  }
  else if (sex_nums[i] == 2) {
    sex_letters <- c(sex_letters, "F")
  }
}
head(as.data.frame(sex_nums, sex_letters))
metadata$sex <- sex_letters
metadata$subject_id <- make.names(metadata$subject_id)
```

Make columns of counts match rows of metadata.
```{r}
metadata_all_samples <- metadata$subject_id
counts_hip_samples <- colnames(counts.unique)

new_names_counts <- vector()
new_names_metadata <- vector()
for (i in 1:length(counts_hip_samples)) {
  for (j in 1:length(metadata_all_samples)) {
    checkpoint <- str_detect(string = counts_hip_samples[i], pattern =  metadata_all_samples[j])
    if (checkpoint) {
      new_names_counts <- c(new_names_counts, counts_hip_samples[i])
      new_names_metadata <- c(new_names_metadata, metadata_all_samples[j])
    }
  }
}

head(as.data.frame(new_names_counts, new_names_metadata)) #check
```

Re-order dataframes.
```{r}
counts.unique <- counts.unique[,new_names_counts]
tempdf <- as.data.frame(new_names_metadata)
colnames(tempdf) <- "subject_id"
metadata <- left_join(x = tempdf, y = metadata, by = "subject_id")
```

```{r}
all.equal(colnames(counts.unique), new_names_counts)
metadata$counts_id <- colnames(counts.unique)
```

Create dge object
```{r}
dge <- DGEList(counts.unique, samples = metadata)
```

Reformat type of sample columns.
```{r}
sample_columns <- c(5:7)
dge$samples[sample_columns] <- 
  lapply(dge$samples[sample_columns], factor)
```

-----------------------------TTR TPM HISTOGRAM----------------------------------

Data is already in TPM (transcripts per million).
Create histogram of TPM TTR values.
```{r}
ttr.counts <- as.data.frame(dge$counts["TTR",])
colnames(ttr.counts) <- "ttr.counts"

log2.ttr.counts <- log2(ttr.counts + 0.01)
colnames(log2.ttr.counts) <- "log2.ttr.counts"
```

```{r}
h1 <- ggplot(ttr.counts, aes(x = ttr.counts)) + 
  geom_histogram(bins = 100, fill = "gray", color = "black") + 
  labs(title = "A.", x=NULL, y=NULL) +
  xlab("TTR TPM") + ylab("# of Samples") + 
  geom_vline(xintercept = 20, col = "red") +
  theme_bw()

h2 <- ggplot(ttr.counts, aes(x = ttr.counts)) + 
  geom_histogram(bins = 100, fill = "gray", color = "black") + 
  labs(title = "B.", x=NULL, y=NULL) +
  xlab("TTR TPM") + ylab("# of Samples") +
  xlim(0, 500) + geom_vline(xintercept = 20, col = "red") + 
  theme_bw() 

h3 <- ggplot(log2.ttr.counts, aes(x = log2.ttr.counts)) + 
  geom_histogram(bins = 100, fill = "gray", color = "black") + 
  labs(title = "C.", x=NULL, y=NULL) +
  xlab("log2(TTR TPM)") + ylab("# of Samples") +
  geom_vline(xintercept = log2(20), col = "red") + theme_bw() +
  geom_vline(xintercept = log2(20) + 1, col = "blue") +
  geom_vline(xintercept = log2(20) - 1, col = "blue")
```


Arrange graphs in grid.
```{r}
plots1 <- list(h1,h2,h3)

layout1 <- rbind(c(1,2),c(3))

grid1 <- grid.arrange(grobs = plots1, layout_matrix = layout1)
```

------------------------------ASSIGN DIRTY/CLEAN/NEITHER------------------------

Lets looks at groups +/- 1 of the cutoff
```{r}
cutoff <- log2(20)
clean_threshold <- cutoff - 1 # values <= this are clean
clean_threshold
cutoff 
dirty_threshold <- cutoff + 1 # values >= this are dirty
dirty_threshold
```

Assign clean or dirty
```{r}
clean_or_dirty <- vector()
vector.log2.ttr.counts <- as.vector(log2.ttr.counts$log2.ttr.counts)

for (i in 1:length(vector.log2.ttr.counts)){
  if (vector.log2.ttr.counts[i] <= clean_threshold){
    clean_or_dirty <- c(clean_or_dirty, "clean")
  }
  else if (vector.log2.ttr.counts[i] >= dirty_threshold){
    clean_or_dirty <- c(clean_or_dirty, "dirty")
  }
  else {
    clean_or_dirty <- c(clean_or_dirty, "neither")
  }
}
table(clean_or_dirty)
```


```{r}
dge$samples$group <- factor(clean_or_dirty)
head(dge$samples)
```

```{r}
h4 <- h3 + 
  annotate("rect", 
              xmin = -Inf,
              xmax = clean_threshold, 
              ymin = 0, 
              ymax=Inf, 
              alpha=0.2, 
              fill="deepskyblue") +
  annotate("rect", 
              xmin = dirty_threshold,
              xmax = Inf, 
              ymin = 0, 
              ymax=Inf, 
              alpha=0.2, 
              fill="chocolate4")
h5 <- h1 + 
  annotate("rect", 
              xmin = -Inf,
              xmax = clean_threshold, 
              ymin = 0, 
              ymax=Inf, 
              alpha=0.2, 
              fill="deepskyblue") +
  annotate("rect", 
              xmin = dirty_threshold,
              xmax = Inf, 
              ymin = 0, 
              ymax=Inf, 
              alpha=0.2, 
              fill="chocolate4")
h4
h5
```


Write table.
```{r}
write.csv(as.data.frame(dge$samples),"metadata_with_groups.txt")
```

-----------------------FILTER LOWLY EXPRESSED GENES-----------------------------

TPM to CPM
```{r}
cpm <- cpm(dge)
```

Filter
```{r}
# produces a logical matrix
thresh <- cpm > 2 # cpm greater than 2

# keep genes that have at least 3 TRUES in each row of thresh
keep <- rowSums(thresh) >= 3
summary(keep)

# redefine object, filter by logical
dge.filtered <- dge[keep, keep.lib.sizes = FALSE]

dim(dge)
dim(dge.filtered)
```
Went from 54,592 genes to 18,883 genes.

--------------------------TRIMMED MEAN OF M-VALUES------------------------------

Now, we want to normalize gene expression distributions. We do this by normalizing 
library size differences in each sample. The method Trimmed Mean of M-values (TMM) 
is used with the calcNormFactors in the edgeR package. The normalization factors 
calculated here are used as a scaling factor for the library size.
  
Trimmed mean of M values (TMM) normalization estimates sequencing
depth after excluding genes for which the ratio of counts between a pair
of experiments is too extreme or for which the average expression is too
extreme. The edgeR software implements a TMM normalization (Biostar Handbook 2020).

```{r}
# creates another large DGEList 
dge.filtered.norm <- calcNormFactors(dge.filtered, method = "TMM")

# view norm factors
dge.filtered.norm$samples$norm.factors
summary(dge.filtered.norm$samples$norm.factors)
```
Looking to be around ~1.


-------------------------------Variance Partition-------------------------------

See what options we have to choose from.
```{r}
colnames(dge.filtered.norm$samples)
```

Specify variables to consider
```{r}
register(SnowParam(4)) # work in parallel

# geneExpr: matrix of gene expression values
# info: information/metadata about each sample
geneExpr <- as.matrix(dge.filtered.norm$counts)
info <- as.data.frame(dge.filtered.norm$samples)

# Age is USUALLY continuous so model it as a fixed effect "age"
# However, this metadata categorizes it into bins so it's categorical
# Sex is categorical, so model them as random effects "(1|sex)"
# Note the syntax
form <- ~ (1|group) + 
  (1|age) + 
  (1|sex) + 
  (1|hardy_scale)

varPart <- fitExtractVarPartModel(geneExpr, form, info)
vp <- sortCols(varPart)
```

Violin plots
```{r}
plotVarPart(vp)
```

Percent bars
```{r}
plotPercentBars(vp[1:10,])
```

```{r}
# sort genes based on variance explained by group
varPart.df <- as.data.frame(varPart)
order.varPart.df <- varPart.df[order(varPart.df$group, decreasing = TRUE),]
order.varPart.df["group"]

```

-----------------------------DESIGN MATRIX--------------------------------------

```{r}
sex <- dge.filtered.norm$samples$sex
age <- dge.filtered.norm$samples$age
```


Create a design matrix and specify the samples we want to compare to each other.
```{r}
# interaction computes a factor which represents the interaction of the given factors
group <- interaction(dge.filtered$samples$group)

design <- model.matrix(~ 0 + group + sex + age)
colnames(design) <- make.names(colnames(design))
colnames(design)[1:2] <- c("clean","dirty")
```

Run voom with quality weights. This combines observational-level weights with
  sample-specific quality weights in an experiment.
Normalizes expression intensities so that the log-ratios have similar distributions
  across a set of samples.
To quantile normalize, add normalize.method = "quantile".

Quality weights in RNA-seq data improves data quality when samples with high
  variance are present.  This variation is modeled by taking into account
  global intensity-dependent trends using voom.  
Sample-specific variability is taken into account with a log-linear model that 
  shares parameters between genes.
https://doi.org/10.1093/nar/gkv412


```{r}
v <- voomWithQualityWeights(dge.filtered.norm, design, plot = TRUE)
```

---------------------------------MDS PLOT---------------------------------------

```{r}
#create a png file# png(filename = "mds_1and2.png", width = 400, height = 400)
#default height and width are 480, default units are "px" (pixels)

group_colors <- c("deepskyblue","chocolate4","gray")[v$targets$group] # blue is clean, brown is dirty
point_shapes <- c("F","M")[v$targets$sex] # will say F or M for points
head(data.frame(v$targets$group, group_colors, v$targets$sex,point_shapes)) # Check everything matches

mds <- plotMDS(
  v, # our data object
  top = 10, # only looking at top 10 genes
  pch = point_shapes,
  cex = 1, # point size
  dim.plot = c(1,2), # specifying principal components to be plotted
  plot = TRUE, # if TRUE then plot is created on current graphics device
  col = group_colors # assigning our colors for each genotype
)

legend(
  "top",
  pch = 16,
  legend = c("clean","dirty","neither"),
  col = c("deepskyblue","chocolate4","gray"),
  cex = 0.8
)

title("Raw Data: Top 10 Genes")
```

-------------------------HIERARCHIAL HEAT CLUSTERING----------------------------

ds[order(factor(Month, levels = c("Apr", "May", "Jan", "Feb", "Mar"))), .SD,ID]
```{r}
current_order <- dge.filtered.norm$samples$counts_id

# reorder levels
group_order <- dge.filtered.norm$samples
group_order <- group_order[order(factor(group, levels = c("dirty","neither","clean"))),]
sample_group_order <- group_order$counts_id
dge.group <- dge.filtered.norm[,sample_group_order]

# sample group colors
sample_group_color <- c("deepskyblue", "chocolate4", "gray")[dge.group$samples$group]
as.data.frame(dge.group$samples$group, sample_group_color)
```



```{r}
# We estimate the variance for each row in the logcounts matrix
logcounts <- cpm(dge.group, log = TRUE) # log2 values
var_genes <- apply(logcounts, 1, var)

# Get the gene names for the top 100 most variable genes
select_var <- names(sort(var_genes, decreasing=TRUE))[1:50]
select_var

# Subset logcounts matrix
highly_variable_lcpm <- logcounts[select_var,]
```


```{r}

my_palette <- colorRampPalette(c("red", "black", "green"))

# Plot the heatmap
map <- heatmap.2(highly_variable_lcpm, 
          main = "Top 50 most variable genes across samples",
          col = my_palette, # heatmap color scale
          ColSideColors = sample_group_color,
          trace = "none",
          dendrogram = "row",
          Colv = sample_group_order,
          colCol = sample_group_color,
          srtCol = 45,
          xlab = "Samples"
          )
```

---------------------------------LINEAR MODELS----------------------------------

Fit linear models for comparisons of interest.
Linear modeling in limma is carried out using the lmFit and contrasts.fit
  functions.
  
What do lm.fit and contrasts.fit do?
  1) Fit a separate model to the expression values for each gene.
  2) An empirical Bayes moderation is carried out by borrowing info across all
     the gene to obtain more precise estimates of gene-wise variability.
  3) The model's residual variances are plotted against average expression 
     values in the next figure.

It can be seen from this plot that the variance is no longer dependent on the 
  mean expression level.
  
```{r}
# Fits linear model for each gene given a series of arrays
fit <- lmFit(
  v,  # object containing log-expression values for a series of arrays
  design  # design matrix
  )

```


Contrast design for differential expression.
```{r}
contrasts <-
  makeContrasts(
    dirty_vs_clean = dirty - clean,
    levels = colnames(design)
  )

head(contrasts)
```

Assign allComparisons to a vector for later use.
```{r}
allComparisons <- colnames(contrasts)
allComparisons # check
```

Run contrast analysis.
Given a linear model fit, compute estimated coefficients and standard errors
  for a given set of contrasts.
```{r}
vfit <- contrasts.fit(fit, contrasts = contrasts)
```

Compute differential expression based on the empirical Bayes moderation of the
  standard errors towards a common value.
```{r}
veBayesFit <- eBayes(vfit)
plotSA(veBayesFit, main = "Final Model: Mean-variance Trend")
```


Looking at N of differentially expressed genes (DEGs) with adjusted p < 0.01 
  and log2FC > 2.

decideTests() identifies which genes are significantly differentially expressed
  for each contrast from a fit object containing p-values and test statistics.
```{r}
sumTable <- 
  summary(decideTests(
    vfit,  # object
    # by default the method = "separate"
    adjust.method = "BH", 
    p.value = 0.05,
    lfc = 1  # numeric, minimum absolute log2-fold change required
  ))

head(sumTable)
```

--------------------------------------DEG TABLES--------------------------------

For each comparison...extract table of the top-ranked genes (DEGs) from a linear 
model fit AND output a table.
  
NOTE: Log2FC of 1 is equivalent to linear fold change of 2.

```{r}
coef = 1
for (i in allComparisons) {
  
  # p < 1, log2fc > 0 ----------------------------------------------------------
  vTopTableAll <-
    topTable(
      veBayesFit, 
      coef = coef,  
      n = Inf, 
      p.value = 1,
      lfc = 0 
    )
  #output as txt file
  path <- paste("DEGs/DEG_", i, "_PVal1_Log2FC0.txt", sep = "") 
  write.table(
    vTopTableAll,
    path,
    sep = "\t",
    row.names = TRUE,
    quote = FALSE
  )
  
  # p < 0.05, log2fc > 0 -------------------------------------------------------
  vTopTable1 <-
    topTable( 
      veBayesFit,  
      coef = coef,  
      n = Inf, 
      p.value = 0.05,
      lfc = 0
    )
  path <- paste("DEGs/DEG_", i, "_PVal0.05_Log2FC0.txt", sep = "") 
  write.table(
    vTopTable1,
    path,
    sep = "\t",
    row.names = TRUE,
    quote = FALSE
  )
  
  # p < 0.10, log2fc > 1 -------------------------------------------------------
  vTopTable5 <-
    topTable( 
      veBayesFit,  
      coef = coef,  
      n = Inf, 
      p.value = 0.05,
      lfc = 1
    )
  path <- paste("DEGs/DEG_", i, "_PVal0.05_Log2FC1.txt", sep = "") 
  write.table(
    vTopTable5,
    path,
    sep = "\t",
    row.names = TRUE,
    quote = FALSE
  )
  
  # p < 0.01, log2fc > 0 -------------------------------------------------------
  vTopTable2 <-
    topTable(  
      veBayesFit,  
      coef = coef,  
      n = Inf, 
      p.value = 0.01,
      lfc = 0 
    )
  path <- paste("DEGs/DEG_", i, "_PVal0.01_Log2FC0.txt", sep = "") 
  write.table(
    vTopTable2,
    path,
    sep = "\t",
    row.names = TRUE,
    quote = FALSE
  )
  
  # p < 0.01, log2fc > 1 -------------------------------------------------------
  vTopTable3 <-
    topTable( 
      veBayesFit,  
      coef = coef,  
      n = Inf, 
      p.value = 0.01,
      lfc = 1 
    )
  path <- paste("DEGs/DEG_", i, "_PVal0.01_Log2FC1.txt", sep = "") 
  write.table(
    vTopTable3,
    path,
    sep = "\t",
    row.names = TRUE,
    quote = FALSE
  )
  
  # p < 0.01, log2fc > 2 -------------------------------------------------------
  vTopTable4 <-
    topTable( 
      veBayesFit,  
      coef = coef,  
      n = Inf, 
      p.value = 0.01,
      lfc = 2 
    )
  path <- paste("DEGs/DEG_", i, "_PVal0.01_Log2FC2.txt", sep = "") 
  write.table(
    vTopTable4,
    path,
    sep = "\t",
    row.names = TRUE,
    quote = FALSE
  )
  
  # p < 0.10, log2fc > 0 -------------------------------------------------------
  vTopTable5 <-
    topTable( 
      veBayesFit,  
      coef = coef,  
      n = Inf, 
      p.value = 0.1,
      lfc = 0
    )
  path <- paste("DEGs/DEG_", i, "_PVal0.1_Log2FC0.txt", sep = "") 
  write.table(
    vTopTable5,
    path,
    sep = "\t",
    row.names = TRUE,
    quote = FALSE
  )
  
  # increment the coefficient --------------------------------------------------
  coef <- coef + 1
}
```


----------------------------------VOLCANO PLOTS---------------------------------

Using the DEG tables we made, graph a volcano plot.
Read in file.
```{r}
dirty_vs_clean <-
  read.table(
    "DEGs/DEG_dirty_vs_clean_PVal1_Log2FC0.txt",
    header = TRUE,
    sep = "\t",
    stringsAsFactors = F
  )
```

```{r}
dirty_vs_clean$gene_symbol <- rownames(dirty_vs_clean)
```


```{r}
summary(decideTests(
    vfit,  # object
    adjust.method = "BH", # by default the method = "separate"
    p.value = 0.05,
    lfc = 1
  ))
```

```{r}
color_values <- vector()
max <- nrow(dirty_vs_clean)

for(i in 1:max){
  if (dirty_vs_clean$adj.P.Val[i] < 0.05){
    if (dirty_vs_clean$logFC[i] > 1){
      color_values <- c(color_values, 1) # 1 when logFC > 1 and pval < 0.05
    }
    else if (dirty_vs_clean$logFC[i] < -1){
      color_values <- c(color_values, 2) # 2 when logFC < -1 and pval < 0.05
    }
    else{
      color_values <- c(color_values, 3) # 3 when -1 =< logFC <= 1 pval < 0.05
    }
  }
  else{
    color_values <- c(color_values, 3) # 3 when pval >= 0.05
  }
}

dirty_vs_clean$color_p0.05_lfc1 <- factor(color_values)
```

```{r}
hadjpval <- (-log10(max(dirty_vs_clean$adj.P.Val[dirty_vs_clean$adj.P.Val < 0.05], na.rm=TRUE)))
hadjpval
```

```{r}
p <-
  ggplot(data = dirty_vs_clean, 
         aes(x = logFC, # x-axis is logFC
             y = -log10(adj.P.Val), # y-axis will be log10 of adj.P.Val
             color = color_p0.05_lfc1)) + # color is based on factored Color column
  geom_point(alpha = 0.8, size = 3) + # create scatterplot, alpha makes points transparent
  theme_bw() +
  theme(legend.position = "none") + # no legend
  xlim(c(-3, 6)) + #ylim(c(0, 25)) + # x and y axis limits
  scale_color_manual(values = c("red", "blue", "grey")) + # set factor colors
  labs(
    title = "", # no main title
    x = expression(log[2](FC)), # x-axis title
    y = expression(-log[10] ~ "(FDR adjusted " ~ italic("p") ~ "-value)") # y-axis title
  ) +
  theme(axis.title.x = element_text(size = 10),
        axis.text.x = element_text(size = 10)) +
  theme(axis.title.y = element_text(size = 10),
        axis.text.y = element_text(size = 10)) +
  geom_hline(yintercept = hadjpval,
                     colour = "#000000",
                     linetype = "dashed") +
    geom_vline(xintercept = 1,
             colour = "#000000",
             linetype = "dashed") +
  geom_vline(xintercept = -1,
             colour = "#000000",
             linetype = "dashed") +
  ggtitle("Dirty vs Clean Hippocampus\nFDRq < 0.05, -1 > LogFC > 1") +
  geom_text_repel(data = subset(dirty_vs_clean, dirty_vs_clean$color_p0.05_lfc1 == 1 |
                                  dirty_vs_clean$color_p0.05_lfc1 == 2),
                  aes(x = logFC, y = -log10(adj.P.Val), label = gene_symbol), 
                  color = "black",
                  fontface="italic",
                  max.overlaps = getOption("ggrepel.max.overlaps", default = 25)
                  )
p
```
